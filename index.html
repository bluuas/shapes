<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Flächenzerlegungen – Interaktive Visualisierungen</title>
<style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        background: #f5f5f5;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    h1 {
        color: #333;
        margin-bottom: 20px;
    }
    
    nav {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    nav button {
        padding: 10px 20px;
        font-size: 16px;
        border: 2px solid #333;
        background: white;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.3s;
    }
    
    nav button:hover {
        background: #e0e0e0;
    }
    
    nav button.active {
        background: #333;
        color: white;
    }
    
    #visualization-title {
        font-size: 24px;
        color: #555;
        margin-bottom: 10px;
        font-weight: bold;
    }
    
    canvas {
        border: 2px solid #333;
        background: white;
        margin-top: 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-radius: 4px;
        display: block;
    }
    
    input[type=range] {
        width: 500px;
        max-width: 90%;
        margin-top: 20px;
        cursor: pointer;
        display: block;
    }
    
    #label {
        font-size: 22px;
        margin-top: 10px;
        color: #555;
        font-weight: bold;
    }
</style>
</head>
<body>

<h1>Flächenzerlegungen – Interaktive Visualisierungen</h1>

<nav>
    <button class="active" onclick="showVisualization('drachen')">Drachen</button>
    <button onclick="showVisualization('parallelogramm')">Parallelogramm</button>
    <button onclick="showVisualization('rhombus')">Rhombus</button>
</nav>

<h2 id="visualization-title">Fläche eines Drachens – Zerlegung</h2>

<div id="label">Zieh mich!</div>
<input id="slider" type="range" min="0" max="1" step="0.001" value="0">

<canvas id="canvas" width="900" height="450"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const slider = document.getElementById("slider");
const title = document.getElementById("visualization-title");

let currentVisualization = 'drachen';

// ========================================
// DRACHEN (KITE)
// ========================================
const drachen = {
    e: 300,   // Grundseite
    f: 200,   // Höhe
    ratio: 0.75, // Verhältnis der Seiten
    x0: 250,  // Startpunkt x
    y0: 150,  // Startpunkt y
    lightBlue: "#ADD8FF",
    darkBlue: "#0050FF",
    padding: 10, // Abstand für Text

    draw: function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const t = Number(slider.value);

        // Punkte des Drachens
        const A = {x: this.x0, y: this.y0 + this.f/2};
        const B = {x: this.x0 + this.e*this.ratio, y: this.y0 + this.f};
        const C = {x: this.x0 + this.e, y: this.y0 + this.f/2};
        const D = {x: this.x0 + this.e*this.ratio, y: this.y0};
        const E = {x: this.x0 + this.e*this.ratio, y: this.y0 + this.f/2}; // Schnittpunkt e f
        
        const midF = (B.y + D.y) / 2; // Mittelpunkt f-Linie

        // Schrittgrenzen (wie GeoGebra)
        const heightStart = 0.15;  // Höhenlinien erscheinen
        const colorStart = 0.30;   // Dreiecke werden farbig
        const mirrorStart = 0.55;  // Dreiecke spiegeln sich
        const moveStart = 0.70;    // Dreiecke bewegen sich nach oben
        const endStart = 0.80;     // Rechteck-Text erscheint

        // Grundform
        drawPolygon([A, C, D], this.lightBlue); // obere Hälfte immer zeichnen
        if (t < colorStart) {
            drawPolygon([A, B, C], this.lightBlue); // untere Hälfte nur bis Spiegelung
        }
        
        // Hilfslinien einblenden / verblassen
        drawLine(A.x, A.y, C.x, C.y, `rgba(0,0,0,${1-t})`);
        drawLine(B.x, B.y, D.x, D.y, `rgba(0,0,0,${1-t})`);
        if (t >= heightStart) {
            drawRectangle(this.x0, this.y0, this.e, this.f, "transparent", `rgba(0,0,0,${t})`, [5, 5]);
        }

        // Höhe Text verschieben
        if (t >= heightStart) {
            const eStart = [this.x0 + (this.e/2), this.y0 + this.f/2 - this.padding];
            const eStop = [this.x0 + (this.e/2), this.y0 - this.padding];
            const ePos = [
                eStart[0] + (eStop[0] - eStart[0]) * Math.min((t - heightStart) / (colorStart - heightStart), 1),
                eStart[1] + (eStop[1] - eStart[1]) * Math.min((t - heightStart) / (colorStart - heightStart), 1)
            ];
            const fStart = [(this.x0 + this.e*this.ratio) + this.padding, midF - this.padding];
            const fStop = [this.x0 + this.e + this.padding, midF + this.padding];
            const fPos = [
                fStart[0] + (fStop[0] - fStart[0]) * Math.min((t - heightStart) / (colorStart - heightStart), 1),
                fStart[1] + (fStop[1] - fStart[1]) * Math.min((t - heightStart) / (colorStart - heightStart), 1)
            ];
            addText(ePos[0], ePos[1], "e");
            addText(fPos[0], fPos[1], "f");
        }
        
        // Dreiecke farbig markieren (aber nur bis es bewegt wird)
        if (t >= colorStart && t < mirrorStart) {
            drawPolygon([A, E, B], this.darkBlue);
            drawPolygon([C, E, B], this.darkBlue);
        }

        // Dreiecke spiegeln
        if (t >= mirrorStart && t < moveStart) {
            const mirrorT = Math.min((t - mirrorStart) / (moveStart - mirrorStart), 1);
            const dx1 = (E.x - A.x) * mirrorT; // Spiegelungspfad linkes Dreieck
            const dx2 = (C.x - E.x) * mirrorT; // Spiegelungspfad rechtes Dreieck

            // linkes Dreieck
            drawPolygon([
                {x: A.x + dx1, y: A.y},
                {x: E.x - dx1, y: E.y},
                {x: B.x - dx1, y: B.y}
            ], this.darkBlue);

            // rechtes Dreieck
            drawPolygon([
                {x: C.x - dx2, y: C.y},
                {x: E.x + dx2, y: E.y},
                {x: B.x + dx2, y: B.y}
            ], this.darkBlue);
        }

        // nach oben verschieben
        if (t >= moveStart) {
            const moveT = Math.min((t - moveStart) / (endStart - moveStart), 1);
            const dy = (this.f/2) * moveT;

            // linkes Dreieck
            drawPolygon([
                {x: A.x, y: A.y - dy},
                {x: E.x, y: E.y - dy},
                {x: A.x, y: B.y - dy}
            ], this.darkBlue);

            // rechtes Dreieck
            drawPolygon([
                {x: C.x, y: C.y - dy},
                {x: E.x, y: E.y - dy},
                {x: C.x, y: B.y - dy}
            ], this.darkBlue);
        }

        // Endzustand: Rechteck
        if (t >= endStart) {
            ctx.font = "26px Arial";
            ctx.fillStyle = "green";
            ctx.fillText("→ Rechteck", this.x0 + this.e + 40, this.y0 + 10);
        }
    }
};

// ========================================
// PARALLELOGRAMM
// ========================================
const parallelogramm = {
    a: 240,   // Grundseite
    h: 140,   // Höhe
    skew: 90, // Schrägversatz

    draw: function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const t = Number(slider.value);

        // Punkte des Parallelogramms
        const A = {x: 250, y: 150};
        const B = {x: 250 + this.a, y: 150};
        const C = {x: 250 + this.a - this.skew, y: 150 + this.h};
        const D = {x: 250 - this.skew, y: 150 + this.h};

        // Dreieck zum Ausschneiden
        const T1 = {x: A.x, y: A.y};
        const T2 = {x: D.x, y: D.y};
        const T3 = {x: A.x, y: D.y};

        // Schrittgrenzen (wie GeoGebra)
        const heightStart = 0.15;
        const colorStart = 0.30;
        const moveStart = 0.55;
        const endStart = 0.80;

        // Beschriftung a und b
        ctx.font = "20px Arial";
        ctx.fillStyle = "black";
        ctx.fillText("a", (A.x + B.x)/2, A.y - 10);

        // 1) Parallelogramm
        if (t < moveStart) {
            ctx.fillText("b", A.x - 70, (A.y + D.y)/2);
            ctx.fillStyle = "#ADD8FF";
            drawPolygon([A, B, C, D]);
        } else {
            ctx.fillStyle = "#ADD8FF";
            const A_new = {x: A.x, y: A.y + this.h};
            drawPolygon([A, B, C, A_new]);
        }

        // 3) Linkes Dreieck farbig markieren (aber nur bis es bewegt wird)
        if (t >= colorStart && t < moveStart) {
            ctx.fillStyle = "#5B8BFF";
            drawPolygon([T1, T2, T3]);
        }

        // 2) Höhe einzeichnen
        if (t >= heightStart) {
            ctx.beginPath();
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(A.x, A.y + this.h);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = "20px Arial";
            ctx.fillStyle = "black";
            ctx.fillText("h", A.x - 20, A.y + this.h/2);
        }

        // 4) Dreieck verschieben
        if (t >= moveStart) {
            const moveT = Math.min((t - moveStart) / (endStart - moveStart), 1);
            
            // Bewegungspfad: von A → B
            const dx = (B.x - A.x) * moveT;
            const dy = (B.y - A.y) * moveT;

            ctx.fillStyle = "#5B8BFF";
            drawPolygon([
                {x: T1.x + dx, y: T1.y + dy},
                {x: T2.x + dx, y: T2.y + dy},
                {x: T3.x + dx, y: T3.y + dy}
            ]);
        }

        // 5) Endzustand: Rechteck
        if (t >= endStart) {
            ctx.font = "26px Arial";
            ctx.fillStyle = "green";
            ctx.fillText("→ Rechteck", B.x + 40, A.y + 10);
        }
    }
};

// ========================================
// RHOMBUS
// ========================================
const rhombus = {
    a: 240,        // Seitenlänge (alle Seiten gleich)
    angleDeg: 125, // Innenwinkel an A

    draw: function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const t = Number(slider.value);

        const angle = this.angleDeg * Math.PI / 180;
        const A = {x: 250, y: 150};
        const B = {x: A.x + this.a, y: A.y};
        
        // Weitere Punkte des Rhombus
        const C = {
            x: B.x + this.a * Math.cos(angle),
            y: B.y + this.a * Math.sin(angle)
        };
        const D = {
            x: A.x + this.a * Math.cos(angle),
            y: A.y + this.a * Math.sin(angle)
        };

        // Höhe des Rhombus (vertikal)
        const h = Math.abs(A.y - D.y);

        // Schritte wie im Original
        const heightStart = 0.15;
        const colorStart = 0.30;
        const moveStart = 0.55;
        const endStart = 0.80;

        // Dreieckspunkte für das linke Dreieck
        const T1 = {x: A.x, y: A.y};
        const T2 = {x: D.x, y: D.y};
        const T3 = {x: A.x, y: D.y};

        // ========= Seitenbeschriftungen =========
        ctx.font = "20px Arial";
        ctx.fillStyle = "black";

        // obere Seite immer
        ctx.fillText("a", (A.x + B.x)/2, A.y - 10);

        // linke Seite immer
        ctx.fillText("a", (A.x + D.x)/2 - 20, (A.y + D.y)/2);

        // schräge Seiten nur bis Bewegung startet
        if (t < moveStart) {
            ctx.fillText("a", (B.x + C.x)/2 + 10, (B.y + C.y)/2);
            ctx.fillText("a", (C.x + D.x)/2, (C.y + D.y)/2 + 20);
        }

        // ========= 1) Rhombus zeichnen =========
        ctx.fillStyle = "#ADD8FF";
        if (t < moveStart) {
            drawPolygon([A, B, C, D]);
        } else {
            const A_new = {x: A.x, y: A.y + h};
            drawPolygon([A, B, C, A_new]);
        }

        // ========= 2) Farbiges Dreieck vor der Bewegung =========
        if (t >= colorStart && t < moveStart) {
            ctx.fillStyle = "#5B8BFF";
            drawPolygon([T1, T2, T3]);
        }

        // ========= 3) Dreieck verschieben =========
        let dx = 0, dy = 0;
        if (t >= moveStart) {
            const moveT = Math.min((t - moveStart) / (endStart - moveStart), 1);
            dx = (B.x - A.x) * moveT;
            dy = (B.y - A.y) * moveT;

            ctx.fillStyle = "#5B8BFF";
            drawPolygon([
                {x: T1.x + dx, y: T1.y + dy},
                {x: T2.x + dx, y: T2.y + dy},
                {x: T3.x + dx, y: T3.y + dy}
            ]);
        }

        // ========= 4) Höhe + h-Beschriftung (IMMER GANZ OBEN!) =========
        if (t >= heightStart) {
            // Höhe-Linie
            ctx.beginPath();
            ctx.moveTo(A.x + dx, A.y + dy);
            ctx.lineTo(A.x + dx, A.y + h + dy);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.stroke();

            // h Position — bewegt sich mit dem Dreieck
            const hx = A.x + dx - 20;
            const hy = A.y + dy + h/2;
            ctx.fillStyle = "black";
            ctx.font = "20px Arial";
            ctx.fillText("h", hx, hy);
        }

        // ========= 5) Endbeschriftung =========
        if (t >= endStart) {
            ctx.font = "26px Arial";
            ctx.fillStyle = "green";
            ctx.fillText("→ Rechteck", B.x + 40, A.y + 10);
        }
    }
};

// ========================================
// HELPER FUNCTIONS
// ========================================
function addText(x, y, text, color = "black", font = "20px Arial") {
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
}

function drawRectangle(x0, y0, width, height, fillColor = "rgba(0,0,0,0)", lineColor = "black", dash = []) {
    ctx.fillStyle = fillColor;
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.rect(x0, y0, width, height);
    ctx.fill();
    ctx.strokeStyle = lineColor;
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawLine(x1, y1, x2, y2, color, dash = []) {
    ctx.strokeStyle = color;
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawPolygon(pts, fillColor, lineColor = "black") {
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = lineColor;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (const p of pts.slice(1)) ctx.lineTo(p.x, p.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// ========================================
// NAVIGATION
// ========================================
function showVisualization(type) {
    currentVisualization = type;
    slider.value = 0;
    
    // Update active button
    document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    // Update title
    const titles = {
        'drachen': 'Fläche eines Drachens – Zerlegung',
        'parallelogramm': 'Fläche eines Parallelogramms – Zerlegung',
        'rhombus': 'Fläche eines Rhombus – Zerlegung'
    };
    title.textContent = titles[type];
    
    draw();
}

function draw() {
    switch(currentVisualization) {
        case 'drachen':
            drachen.draw();
            break;
        case 'parallelogramm':
            parallelogramm.draw();
            break;
        case 'rhombus':
            rhombus.draw();
            break;
    }
}

slider.oninput = draw;
draw();
</script>

</body>
</html>
